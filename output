1
static
14
 
1
int
14
 
2
kernel_init
6
(
1
void
14
 
5
*
6
)
6
;
14


14


1
extern
14
 
1
void
14
 
2
init_IRQ
6
(
1
void
6
)
6
;
14


1
extern
14
 
1
void
14
 
2
fork_init
6
(
1
void
6
)
6
;
14


1
extern
14
 
1
void
14
 
2
radix_tree_init
6
(
1
void
6
)
6
;
14


14


7
/*
 * Debug helper: via this flag we know that we are in 'early bootup code'
 * where only the boot processor is running with IRQ disabled.  This means
 * two things - IRQ must not be enabled before the flag is cleared and some
 * operations which are not allowed with IRQ disabled are allowed while the
 * flag is set.
 */
14


2
bool
14
 
2
early_boot_irqs_disabled
14
 
2
__read_mostly
6
;
14


14


1
enum
14
 
2
system_states
14
 
2
system_state
14
 
2
__read_mostly
6
;
14


2
EXPORT_SYMBOL
6
(
2
system_state
6
)
6
;
14


14


7
/*
 * Boot command-line arguments
 */
14


9
#define MAX_INIT_ARGS CONFIG_INIT_ENV_ARG_LIMIT
14


9
#define MAX_INIT_ENVS CONFIG_INIT_ENV_ARG_LIMIT
14


14


1
extern
14
 
1
void
14
 
2
time_init
6
(
1
void
6
)
6
;
14


7
/* Default late time init is NULL. archs can override this later. */
14


1
void
14
 
6
(
5
*
2
__initdata
14
 
2
late_time_init
6
)
6
(
1
void
6
)
6
;
14


14


7
/* Untouched command line saved by arch-specific code. */
14


1
char
14
 
2
__initdata
14
 
2
boot_command_line
6
[
2
COMMAND_LINE_SIZE
6
]
6
;
14


7
/* Untouched saved command line (eg. for /proc) */
14


1
char
14
 
5
*
2
saved_command_line
6
;
14


7
/* Command line for parameter parsing */
14


1
static
14
 
1
char
14
 
5
*
2
static_command_line
6
;
14


7
/* Command line for per-initcall parameter parsing */
14


1
static
14
 
1
char
14
 
5
*
2
initcall_command_line
6
;
14


14


1
static
14
 
1
char
14
 
5
*
2
execute_command
6
;
14


1
static
14
 
1
char
14
 
5
*
2
ramdisk_execute_command
6
;
14


14


7
/*
 * Used to generate warnings if static_key manipulation functions are used
 * before jump_label_init is called.
 */
14


2
bool
14
 
2
static_key_initialized
14
 
2
__read_mostly
6
;
14


2
EXPORT_SYMBOL_GPL
6
(
2
static_key_initialized
6
)
6
;
14


14


7
/*
 * If set, this is an indication to the drivers that reset the underlying
 * device before going ahead with the initialization otherwise driver might
 * rely on the BIOS and skip the reset operation.
 *
 * This is useful if kernel is booting in an unreliable environment.
 * For ex. kdump situation where previous kernel has crashed, BIOS has been
 * skipped and devices will be in unknown state.
 */
14


1
unsigned
14
 
1
int
14
 
2
reset_devices
6
;
14


2
EXPORT_SYMBOL
6
(
2
reset_devices
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
set_reset_devices
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
2
reset_devices
14
 
6
=
14
 
3
1
6
;
14


14
	
1
return
14
 
3
1
6
;
14


6
}
14


14


2
__setup
6
(
12
"reset_devices"
6
,
14
 
2
set_reset_devices
6
)
6
;
14


14


1
static
14
 
1
const
14
 
1
char
14
 
5
*
2
argv_init
6
[
2
MAX_INIT_ARGS
3
+2
6
]
14
 
6
=
14
 
6
{
14
 
12
"init"
6
,
14
 
2
NULL
6
,
14
 
6
}
6
;
14


1
const
14
 
1
char
14
 
5
*
2
envp_init
6
[
2
MAX_INIT_ENVS
3
+2
6
]
14
 
6
=
14
 
6
{
14
 
12
"HOME=/"
6
,
14
 
12
"TERM=linux"
6
,
14
 
2
NULL
6
,
14
 
6
}
6
;
14


1
static
14
 
1
const
14
 
1
char
14
 
5
*
2
panic_later
6
,
14
 
5
*
2
panic_param
6
;
14


14


1
extern
14
 
1
const
14
 
1
struct
14
 
2
obs_kernel_param
14
 
2
__setup_start
6
[
6
]
6
,
14
 
2
__setup_end
6
[
6
]
6
;
14


14


1
static
14
 
2
bool
14
 
2
__init
14
 
2
obsolete_checksetup
6
(
1
char
14
 
5
*
2
line
6
)
14


6
{
14


14
	
1
const
14
 
1
struct
14
 
2
obs_kernel_param
14
 
5
*
2
p
6
;
14


14
	
2
bool
14
 
2
had_early_param
14
 
6
=
14
 
2
false
6
;
14


14


14
	
2
p
14
 
6
=
14
 
2
__setup_start
6
;
14


14
	
1
do
14
 
6
{
14


14
	
14
	
1
int
14
 
2
n
14
 
6
=
14
 
2
strlen
6
(
2
p
5
-
5
>
2
str
6
)
6
;
14


14
	
14
	
1
if
14
 
6
(
2
parameqn
6
(
2
line
6
,
14
 
2
p
5
-
5
>
2
str
6
,
14
 
2
n
6
)
6
)
14
 
6
{
14


14
	
14
	
14
	
1
if
14
 
6
(
2
p
5
-
5
>
2
early
6
)
14
 
6
{
14


14
	
14
	
14
	
14
	
7
/* Already done in parse_early_param?
				 * (Needs exact match on param part).
				 * Keep iterating, as we can have early
				 * params and __setups of same names 8( */
14


14
	
14
	
14
	
14
	
1
if
14
 
6
(
2
line
6
[
2
n
6
]
14
 
5
==
14
 
11
'\0'
14
 
5
||
14
 
2
line
6
[
2
n
6
]
14
 
5
==
14
 
11
'='
6
)
14


14
	
14
	
14
	
14
	
14
	
2
had_early_param
14
 
6
=
14
 
2
true
6
;
14


14
	
14
	
14
	
6
}
14
 
1
else
14
 
1
if
14
 
6
(
5
!
2
p
5
-
5
>
2
setup_func
6
)
14
 
6
{
14


14
	
14
	
14
	
14
	
2
pr_warn
6
(
12
"Parameter %s is obsolete, ignored\n"
6
,
14


14
	
14
	
14
	
14
	
14
	
2
p
5
-
5
>
2
str
6
)
6
;
14


14
	
14
	
14
	
14
	
1
return
14
 
2
true
6
;
14


14
	
14
	
14
	
6
}
14
 
1
else
14
 
1
if
14
 
6
(
2
p
5
-
5
>
2
setup_func
6
(
2
line
14
 
5
+
14
 
2
n
6
)
6
)
14


14
	
14
	
14
	
14
	
1
return
14
 
2
true
6
;
14


14
	
14
	
6
}
14


14
	
14
	
2
p
5
++
6
;
14


14
	
6
}
14
 
1
while
14
 
6
(
2
p
14
 
5
<
14
 
2
__setup_end
6
)
6
;
14


14


14
	
1
return
14
 
2
had_early_param
6
;
14


6
}
14


14


7
/*
 * This should be approx 2 Bo*oMips to start (note initial shift), and will
 * still work even if initially too large, it will just take slightly longer
 */
14


1
unsigned
14
 
1
long
14
 
2
loops_per_jiffy
14
 
6
=
14
 
6
(
3
1
5
<<
3
12
6
)
6
;
14


2
EXPORT_SYMBOL
6
(
2
loops_per_jiffy
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
debug_kernel
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
2
console_loglevel
14
 
6
=
14
 
2
CONSOLE_LOGLEVEL_DEBUG
6
;
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
quiet_kernel
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
2
console_loglevel
14
 
6
=
14
 
2
CONSOLE_LOGLEVEL_QUIET
6
;
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


2
early_param
6
(
12
"debug"
6
,
14
 
2
debug_kernel
6
)
6
;
14


2
early_param
6
(
12
"quiet"
6
,
14
 
2
quiet_kernel
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
loglevel
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
1
int
14
 
2
newlevel
6
;
14


14


14
	
7
/*
	 * Only update loglevel value when a correct setting was passed,
	 * to prevent blind crashes (when loglevel being set to 0) that
	 * are quite hard to debug
	 */
14


14
	
1
if
14
 
6
(
2
get_option
6
(
5
&
2
str
6
,
14
 
5
&
2
newlevel
6
)
6
)
14
 
6
{
14


14
	
14
	
2
console_loglevel
14
 
6
=
14
 
2
newlevel
6
;
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14
	
6
}
14


14


14
	
1
return
14
 
5
-
2
EINVAL
6
;
14


6
}
14


14


2
early_param
6
(
12
"loglevel"
6
,
14
 
2
loglevel
6
)
6
;
14


14


7
/* Change NUL term back to "=", to make "param" the whole string. */
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
repair_env_string
6
(
1
char
14
 
5
*
2
param
6
,
14
 
1
char
14
 
5
*
2
val
6
,
14


14
	
14
	
14
	
14
	
14
 
14
 
14
 
14
 
1
const
14
 
1
char
14
 
5
*
2
unused
6
,
14
 
1
void
14
 
5
*
2
arg
6
)
14


6
{
14


14
	
1
if
14
 
6
(
2
val
6
)
14
 
6
{
14


14
	
14
	
7
/* param=val or param="val"? */
14


14
	
14
	
1
if
14
 
6
(
2
val
14
 
5
==
14
 
2
param
5
+
2
strlen
6
(
2
param
6
)
3
+1
6
)
14


14
	
14
	
14
	
2
val
6
[
3
-1
6
]
14
 
6
=
14
 
11
'='
6
;
14


14
	
14
	
1
else
14
 
1
if
14
 
6
(
2
val
14
 
5
==
14
 
2
param
5
+
2
strlen
6
(
2
param
6
)
3
+2
6
)
14
 
6
{
14


14
	
14
	
14
	
2
val
6
[
3
-2
6
]
14
 
6
=
14
 
11
'='
6
;
14


14
	
14
	
14
	
2
memmove
6
(
2
val
3
-1
6
,
14
 
2
val
6
,
14
 
2
strlen
6
(
2
val
6
)
3
+1
6
)
6
;
14


14
	
14
	
14
	
2
val
5
--
6
;
14


14
	
14
	
6
}
14
 
1
else
14


14
	
14
	
14
	
2
BUG
6
(
6
)
6
;
14


14
	
6
}
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


7
/* Anything after -- gets handed straight to init. */
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
set_init_arg
6
(
1
char
14
 
5
*
2
param
6
,
14
 
1
char
14
 
5
*
2
val
6
,
14


14
	
14
	
14
	
14
 
14
 
14
 
14
 
14
 
14
 
14
 
1
const
14
 
1
char
14
 
5
*
2
unused
6
,
14
 
1
void
14
 
5
*
2
arg
6
)
14


6
{
14


14
	
1
unsigned
14
 
1
int
14
 
2
i
6
;
14


14


14
	
1
if
14
 
6
(
2
panic_later
6
)
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14


14
	
2
repair_env_string
6
(
2
param
6
,
14
 
2
val
6
,
14
 
2
unused
6
,
14
 
2
NULL
6
)
6
;
14


14


14
	
1
for
14
 
6
(
2
i
14
 
6
=
14
 
3
0
6
;
14
 
2
argv_init
6
[
2
i
6
]
6
;
14
 
2
i
5
++
6
)
14
 
6
{
14


14
	
14
	
1
if
14
 
6
(
2
i
14
 
5
==
14
 
2
MAX_INIT_ARGS
6
)
14
 
6
{
14


14
	
14
	
14
	
2
panic_later
14
 
6
=
14
 
12
"init"
6
;
14


14
	
14
	
14
	
2
panic_param
14
 
6
=
14
 
2
param
6
;
14


14
	
14
	
14
	
1
return
14
 
3
0
6
;
14


14
	
14
	
6
}
14


14
	
6
}
14


14
	
2
argv_init
6
[
2
i
6
]
14
 
6
=
14
 
2
param
6
;
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


7
/*
 * Unknown boot options get handed to init, unless they look like
 * unused parameters (modprobe will find them in /proc/cmdline).
 */
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
unknown_bootoption
6
(
1
char
14
 
5
*
2
param
6
,
14
 
1
char
14
 
5
*
2
val
6
,
14


14
	
14
	
14
	
14
	
14
 
14
 
14
 
14
 
14
 
1
const
14
 
1
char
14
 
5
*
2
unused
6
,
14
 
1
void
14
 
5
*
2
arg
6
)
14


6
{
14


14
	
2
repair_env_string
6
(
2
param
6
,
14
 
2
val
6
,
14
 
2
unused
6
,
14
 
2
NULL
6
)
6
;
14


14


14
	
7
/* Handle obsolete-style parameters */
14


14
	
1
if
14
 
6
(
2
obsolete_checksetup
6
(
2
param
6
)
6
)
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14


14
	
7
/* Unused module parameter. */
14


14
	
1
if
14
 
6
(
2
strchr
6
(
2
param
6
,
14
 
11
'.'
6
)
14
 
5
&&
14
 
6
(
5
!
2
val
14
 
5
||
14
 
2
strchr
6
(
2
param
6
,
14
 
11
'.'
6
)
14
 
5
<
14
 
2
val
6
)
6
)
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14


14
	
1
if
14
 
6
(
2
panic_later
6
)
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14


14
	
1
if
14
 
6
(
2
val
6
)
14
 
6
{
14


14
	
14
	
7
/* Environment option */
14


14
	
14
	
1
unsigned
14
 
1
int
14
 
2
i
6
;
14


14
	
14
	
1
for
14
 
6
(
2
i
14
 
6
=
14
 
3
0
6
;
14
 
2
envp_init
6
[
2
i
6
]
6
;
14
 
2
i
5
++
6
)
14
 
6
{
14


14
	
14
	
14
	
1
if
14
 
6
(
2
i
14
 
5
==
14
 
2
MAX_INIT_ENVS
6
)
14
 
6
{
14


14
	
14
	
14
	
14
	
2
panic_later
14
 
6
=
14
 
12
"env"
6
;
14


14
	
14
	
14
	
14
	
2
panic_param
14
 
6
=
14
 
2
param
6
;
14


14
	
14
	
14
	
6
}
14


14
	
14
	
14
	
1
if
14
 
6
(
5
!
2
strncmp
6
(
2
param
6
,
14
 
2
envp_init
6
[
2
i
6
]
6
,
14
 
2
val
14
 
5
-
14
 
2
param
6
)
6
)
14


14
	
14
	
14
	
14
	
1
break
6
;
14


14
	
14
	
6
}
14


14
	
14
	
2
envp_init
6
[
2
i
6
]
14
 
6
=
14
 
2
param
6
;
14


14
	
6
}
14
 
1
else
14
 
6
{
14


14
	
14
	
7
/* Command line option */
14


14
	
14
	
1
unsigned
14
 
1
int
14
 
2
i
6
;
14


14
	
14
	
1
for
14
 
6
(
2
i
14
 
6
=
14
 
3
0
6
;
14
 
2
argv_init
6
[
2
i
6
]
6
;
14
 
2
i
5
++
6
)
14
 
6
{
14


14
	
14
	
14
	
1
if
14
 
6
(
2
i
14
 
5
==
14
 
2
MAX_INIT_ARGS
6
)
14
 
6
{
14


14
	
14
	
14
	
14
	
2
panic_later
14
 
6
=
14
 
12
"init"
6
;
14


14
	
14
	
14
	
14
	
2
panic_param
14
 
6
=
14
 
2
param
6
;
14


14
	
14
	
14
	
6
}
14


14
	
14
	
6
}
14


14
	
14
	
2
argv_init
6
[
2
i
6
]
14
 
6
=
14
 
2
param
6
;
14


14
	
6
}
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
init_setup
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
1
unsigned
14
 
1
int
14
 
2
i
6
;
14


14


14
	
2
execute_command
14
 
6
=
14
 
2
str
6
;
14


14
	
7
/*
	 * In case LILO is going to boot us with default command line,
	 * it prepends "auto" before the whole cmdline which makes
	 * the shell think it should execute a script with such name.
	 * So we ignore all arguments entered _before_ init=... [MJ]
	 */
14


14
	
1
for
14
 
6
(
2
i
14
 
6
=
14
 
3
1
6
;
14
 
2
i
14
 
5
<
14
 
2
MAX_INIT_ARGS
6
;
14
 
2
i
5
++
6
)
14


14
	
14
	
2
argv_init
6
[
2
i
6
]
14
 
6
=
14
 
2
NULL
6
;
14


14
	
1
return
14
 
3
1
6
;
14


6
}
14


2
__setup
6
(
12
"init="
6
,
14
 
2
init_setup
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
rdinit_setup
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
1
unsigned
14
 
1
int
14
 
2
i
6
;
14


14


14
	
2
ramdisk_execute_command
14
 
6
=
14
 
2
str
6
;
14


14
	
7
/* See "auto" comment in init_setup */
14


14
	
1
for
14
 
6
(
2
i
14
 
6
=
14
 
3
1
6
;
14
 
2
i
14
 
5
<
14
 
2
MAX_INIT_ARGS
6
;
14
 
2
i
5
++
6
)
14


14
	
14
	
2
argv_init
6
[
2
i
6
]
14
 
6
=
14
 
2
NULL
6
;
14


14
	
1
return
14
 
3
1
6
;
14


6
}
14


2
__setup
6
(
12
"rdinit="
6
,
14
 
2
rdinit_setup
6
)
6
;
14


14


9
#ifndef CONFIG_SMP
14


1
static
14
 
1
const
14
 
1
unsigned
14
 
1
int
14
 
2
setup_max_cpus
14
 
6
=
14
 
2
NR_CPUS
6
;
14


1
static
14
 
2
inline
14
 
1
void
14
 
2
setup_nr_cpu_ids
6
(
1
void
6
)
14
 
6
{
14
 
6
}
14


1
static
14
 
2
inline
14
 
1
void
14
 
2
smp_prepare_cpus
6
(
1
unsigned
14
 
1
int
14
 
2
maxcpus
6
)
14
 
6
{
14
 
6
}
14


9
#endif
14


14


7
/*
 * We need to store the untouched command line for future reference.
 * We also need to store the touched command line since the parameter
 * parsing is performed in place, and we should allow a component to
 * store reference of name/value for future reference.
 */
14


1
static
14
 
1
void
14
 
2
__init
14
 
2
setup_command_line
6
(
1
char
14
 
5
*
2
command_line
6
)
14


6
{
14


14
	
2
saved_command_line
14
 
6
=
14


14
	
14
	
2
memblock_virt_alloc
6
(
2
strlen
6
(
2
boot_command_line
6
)
14
 
5
+
14
 
3
1
6
,
14
 
3
0
6
)
6
;
14


14
	
2
initcall_command_line
14
 
6
=
14


14
	
14
	
2
memblock_virt_alloc
6
(
2
strlen
6
(
2
boot_command_line
6
)
14
 
5
+
14
 
3
1
6
,
14
 
3
0
6
)
6
;
14


14
	
2
static_command_line
14
 
6
=
14
 
2
memblock_virt_alloc
6
(
2
strlen
6
(
2
command_line
6
)
14
 
5
+
14
 
3
1
6
,
14
 
3
0
6
)
6
;
14


14
	
2
strcpy
6
(
2
saved_command_line
6
,
14
 
2
boot_command_line
6
)
6
;
14


14
	
2
strcpy
6
(
2
static_command_line
6
,
14
 
2
command_line
6
)
6
;
14


6
}
14


14


7
/*
 * We need to finalize in a non-__init function or else race conditions
 * between the root thread and the init thread may cause start_kernel to
 * be reaped by free_initmem before the root thread has proceeded to
 * cpu_idle.
 *
 * gcc-3.4 accidentally inlines this function, so use noinline.
 */
14


14


1
static
14
 
2
__initdata
14
 
2
DECLARE_COMPLETION
6
(
2
kthreadd_done
6
)
6
;
14


14


1
static
14
 
2
noinline
14
 
1
void
14
 
2
__ref
14
 
2
rest_init
6
(
1
void
6
)
14


6
{
14


14
	
1
struct
14
 
2
task_struct
14
 
5
*
2
tsk
6
;
14


14
	
1
int
14
 
2
pid
6
;
14


14


14
	
2
rcu_scheduler_starting
6
(
6
)
6
;
14


14
	
7
/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
14


14
	
2
pid
14
 
6
=
14
 
2
kernel_thread
6
(
2
kernel_init
6
,
14
 
2
NULL
6
,
14
 
2
CLONE_FS
6
)
6
;
14


14
	
7
/*
	 * Pin init on the boot CPU. Task migration is not properly working
	 * until sched_init_smp() has been run. It will set the allowed
	 * CPUs for init to the non isolated CPUs.
	 */
14


14
	
2
rcu_read_lock
6
(
6
)
6
;
14


14
	
2
tsk
14
 
6
=
14
 
2
find_task_by_pid_ns
6
(
2
pid
6
,
14
 
5
&
2
init_pid_ns
6
)
6
;
14


14
	
2
set_cpus_allowed_ptr
6
(
2
tsk
6
,
14
 
2
cpumask_of
6
(
2
smp_processor_id
6
(
6
)
6
)
6
)
6
;
14


14
	
2
rcu_read_unlock
6
(
6
)
6
;
14


14


14
	
2
numa_default_policy
6
(
6
)
6
;
14


14
	
2
pid
14
 
6
=
14
 
2
kernel_thread
6
(
2
kthreadd
6
,
14
 
2
NULL
6
,
14
 
2
CLONE_FS
14
 
5
|
14
 
2
CLONE_FILES
6
)
6
;
14


14
	
2
rcu_read_lock
6
(
6
)
6
;
14


14
	
2
kthreadd_task
14
 
6
=
14
 
2
find_task_by_pid_ns
6
(
2
pid
6
,
14
 
5
&
2
init_pid_ns
6
)
6
;
14


14
	
2
rcu_read_unlock
6
(
6
)
6
;
14


14


14
	
7
/*
	 * Enable might_sleep() and smp_processor_id() checks.
	 * They cannot be enabled earlier because with CONFIG_PRREMPT=y
	 * kernel_thread() would trigger might_sleep() splats. With
	 * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled
	 * already, but it's stuck on the kthreadd_done completion.
	 */
14


14
	
2
system_state
14
 
6
=
14
 
2
SYSTEM_SCHEDULING
6
;
14


14


14
	
2
complete
6
(
5
&
2
kthreadd_done
6
)
6
;
14


14


14
	
7
/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
14


14
	
2
schedule_preempt_disabled
6
(
6
)
6
;
14


14
	
7
/* Call into cpu_idle with preempt disabled */
14


14
	
2
cpu_startup_entry
6
(
2
CPUHP_ONLINE
6
)
6
;
14


6
}
14


14


7
/* Check for early params. */
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
do_early_param
6
(
1
char
14
 
5
*
2
param
6
,
14
 
1
char
14
 
5
*
2
val
6
,
14


14
	
14
	
14
	
14
	
14
 
1
const
14
 
1
char
14
 
5
*
2
unused
6
,
14
 
1
void
14
 
5
*
2
arg
6
)
14


6
{
14


14
	
1
const
14
 
1
struct
14
 
2
obs_kernel_param
14
 
5
*
2
p
6
;
14


14


14
	
1
for
14
 
6
(
2
p
14
 
6
=
14
 
2
__setup_start
6
;
14
 
2
p
14
 
5
<
14
 
2
__setup_end
6
;
14
 
2
p
5
++
6
)
14
 
6
{
14


14
	
14
	
1
if
14
 
6
(
6
(
2
p
5
-
5
>
2
early
14
 
5
&&
14
 
2
parameq
6
(
2
param
6
,
14
 
2
p
5
-
5
>
2
str
6
)
6
)
14
 
5
||
14


14
	
14
	
14
 
14
 
14
 
14
 
6
(
2
strcmp
6
(
2
param
6
,
14
 
12
"console"
6
)
14
 
5
==
14
 
3
0
14
 
5
&&
14


14
	
14
	
14
 
14
 
14
 
14
 
14
 
2
strcmp
6
(
2
p
5
-
5
>
2
str
6
,
14
 
12
"earlycon"
6
)
14
 
5
==
14
 
3
0
6
)
14


14
	
14
	
6
)
14
 
6
{
14


14
	
14
	
14
	
1
if
14
 
6
(
2
p
5
-
5
>
2
setup_func
6
(
2
val
6
)
14
 
5
!=
14
 
3
0
6
)
14


14
	
14
	
14
	
14
	
2
pr_warn
6
(
12
"Malformed early option '%s'\n"
6
,
14
 
2
param
6
)
6
;
14


14
	
14
	
6
}
14


14
	
6
}
14


14
	
7
/* We accept everything at this stage. */
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


1
void
14
 
2
__init
14
 
2
parse_early_options
6
(
1
char
14
 
5
*
2
cmdline
6
)
14


6
{
14


14
	
2
parse_args
6
(
12
"early options"
6
,
14
 
2
cmdline
6
,
14
 
2
NULL
6
,
14
 
3
0
6
,
14
 
3
0
6
,
14
 
3
0
6
,
14
 
2
NULL
6
,
14


14
	
14
	
14
 
14
 
14
 
2
do_early_param
6
)
6
;
14


6
}
14


14


7
/* Arch code calls this early on, or if not, just before other parsing. */
14


1
void
14
 
2
__init
14
 
2
parse_early_param
6
(
1
void
6
)
14


6
{
14


14
	
1
static
14
 
1
int
14
 
2
done
14
 
2
__initdata
6
;
14


14
	
1
static
14
 
1
char
14
 
2
tmp_cmdline
6
[
2
COMMAND_LINE_SIZE
6
]
14
 
2
__initdata
6
;
14


14


14
	
1
if
14
 
6
(
2
done
6
)
14


14
	
14
	
1
return
6
;
14


14


14
	
7
/* All fall through to do_early_param. */
14


14
	
2
strlcpy
6
(
2
tmp_cmdline
6
,
14
 
2
boot_command_line
6
,
14
 
2
COMMAND_LINE_SIZE
6
)
6
;
14


14
	
2
parse_early_options
6
(
2
tmp_cmdline
6
)
6
;
14


14
	
2
done
14
 
6
=
14
 
3
1
6
;
14


6
}
14


14


1
void
14
 
2
__init
14
 
2
__weak
14
 
2
arch_post_acpi_subsys_init
6
(
1
void
6
)
14
 
6
{
14
 
6
}
14


14


1
void
14
 
2
__init
14
 
2
__weak
14
 
2
smp_setup_processor_id
6
(
1
void
6
)
14


6
{
14


6
}
14


14


9
# if THREAD_SIZE >= PAGE_SIZE
14


1
void
14
 
2
__init
14
 
2
__weak
14
 
2
thread_stack_cache_init
6
(
1
void
6
)
14


6
{
14


6
}
14


9
#endif
14


14


1
void
14
 
2
__init
14
 
2
__weak
14
 
2
mem_encrypt_init
6
(
1
void
6
)
14
 
6
{
14
 
6
}
14


14


7
/*
 * Set up kernel memory allocators
 */
14


1
static
14
 
1
void
14
 
2
__init
14
 
2
mm_init
6
(
1
void
6
)
14


6
{
14


14
	
7
/*
	 * page_ext requires contiguous pages,
	 * bigger than MAX_ORDER unless SPARSEMEM.
	 */
14


14
	
2
page_ext_init_flatmem
6
(
6
)
6
;
14


14
	
2
mem_init
6
(
6
)
6
;
14


14
	
2
kmem_cache_init
6
(
6
)
6
;
14


14
	
2
pgtable_init
6
(
6
)
6
;
14


14
	
2
vmalloc_init
6
(
6
)
6
;
14


14
	
2
ioremap_huge_init
6
(
6
)
6
;
14


6
}
14


14


2
asmlinkage
14
 
2
__visible
14
 
1
void
14
 
2
__init
14
 
2
start_kernel
6
(
1
void
6
)
14


6
{
14


14
	
1
char
14
 
5
*
2
command_line
6
;
14


14
	
1
char
14
 
5
*
2
after_dashes
6
;
14


14


14
	
2
set_task_stack_end_magic
6
(
5
&
2
init_task
6
)
6
;
14


14
	
2
smp_setup_processor_id
6
(
6
)
6
;
14


14
	
2
debug_objects_early_init
6
(
6
)
6
;
14


14


14
	
2
cgroup_init_early
6
(
6
)
6
;
14


14


14
	
2
local_irq_disable
6
(
6
)
6
;
14


14
	
2
early_boot_irqs_disabled
14
 
6
=
14
 
2
true
6
;
14


14


14
	
7
/*
	 * Interrupts are still disabled. Do necessary setups, then
	 * enable them.
	 */
14


14
	
2
boot_cpu_init
6
(
6
)
6
;
14


14
	
2
page_address_init
6
(
6
)
6
;
14


14
	
2
pr_notice
6
(
12
"%s"
6
,
14
 
2
linux_banner
6
)
6
;
14


14
	
2
setup_arch
6
(
5
&
2
command_line
6
)
6
;
14


14
	
7
/*
	 * Set up the the initial canary and entropy after arch
	 * and after adding latent and command line entropy.
	 */
14


14
	
2
add_latent_entropy
6
(
6
)
6
;
14


14
	
2
add_device_randomness
6
(
2
command_line
6
,
14
 
2
strlen
6
(
2
command_line
6
)
6
)
6
;
14


14
	
2
boot_init_stack_canary
6
(
6
)
6
;
14


14
	
2
mm_init_cpumask
6
(
5
&
2
init_mm
6
)
6
;
14


14
	
2
setup_command_line
6
(
2
command_line
6
)
6
;
14


14
	
2
setup_nr_cpu_ids
6
(
6
)
6
;
14


14
	
2
setup_per_cpu_areas
6
(
6
)
6
;
14


14
	
2
boot_cpu_state_init
6
(
6
)
6
;
14


14
	
2
smp_prepare_boot_cpu
6
(
6
)
6
;
14
	
7
/* arch-specific boot-cpu hooks */
14


14


14
	
2
build_all_zonelists
6
(
2
NULL
6
)
6
;
14


14
	
2
page_alloc_init
6
(
6
)
6
;
14


14


14
	
2
pr_notice
6
(
12
"Kernel command line: %s\n"
6
,
14
 
2
boot_command_line
6
)
6
;
14


14
	
2
parse_early_param
6
(
6
)
6
;
14


14
	
2
after_dashes
14
 
6
=
14
 
2
parse_args
6
(
12
"Booting kernel"
6
,
14


14
	
14
	
14
	
14
	
14
 
14
 
2
static_command_line
6
,
14
 
2
__start___param
6
,
14


14
	
14
	
14
	
14
	
14
 
14
 
2
__stop___param
14
 
5
-
14
 
2
__start___param
6
,
14


14
	
14
	
14
	
14
	
14
 
14
 
3
-1
6
,
14
 
3
-1
6
,
14
 
2
NULL
6
,
14
 
5
&
2
unknown_bootoption
6
)
6
;
14


14
	
1
if
14
 
6
(
5
!
2
IS_ERR_OR_NULL
6
(
2
after_dashes
6
)
6
)
14


14
	
14
	
2
parse_args
6
(
12
"Setting init args"
6
,
14
 
2
after_dashes
6
,
14
 
2
NULL
6
,
14
 
3
0
6
,
14
 
3
-1
6
,
14
 
3
-1
6
,
14


14
	
14
	
14
	
14
 
14
 
14
 
2
NULL
6
,
14
 
2
set_init_arg
6
)
6
;
14


14


14
	
2
jump_label_init
6
(
6
)
6
;
14


14


14
	
7
/*
	 * These use large bootmem allocations and must precede
	 * kmem_cache_init()
	 */
14


14
	
2
setup_log_buf
6
(
3
0
6
)
6
;
14


14
	
2
pidhash_init
6
(
6
)
6
;
14


14
	
2
vfs_caches_init_early
6
(
6
)
6
;
14


14
	
2
sort_main_extable
6
(
6
)
6
;
14


14
	
2
trap_init
6
(
6
)
6
;
14


14
	
2
mm_init
6
(
6
)
6
;
14


14


14
	
2
ftrace_init
6
(
6
)
6
;
14


14


14
	
7
/* trace_printk can be enabled here */
14


14
	
2
early_trace_init
6
(
6
)
6
;
14


14


14
	
7
/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */
14


14
	
2
sched_init
6
(
6
)
6
;
14


14
	
7
/*
	 * Disable preemption - early bootup scheduling is extremely
	 * fragile until we cpu_idle() for the first time.
	 */
14


14
	
2
preempt_disable
6
(
6
)
6
;
14


14
	
1
if
14
 
6
(
2
WARN
6
(
5
!
2
irqs_disabled
6
(
6
)
6
,
14


14
	
14
	
14
 
12
"Interrupts were enabled *very* early, fixing it\n"
6
)
6
)
14


14
	
14
	
2
local_irq_disable
6
(
6
)
6
;
14


14
	
2
radix_tree_init
6
(
6
)
6
;
14


14


14
	
7
/*
	 * Allow workqueue creation and work item queueing/cancelling
	 * early.  Work item execution depends on kthreads and starts after
	 * workqueue_init().
	 */
14


14
	
2
workqueue_init_early
6
(
6
)
6
;
14


14


14
	
2
rcu_init
6
(
6
)
6
;
14


14


14
	
7
/* Trace events are available after this */
14


14
	
2
trace_init
6
(
6
)
6
;
14


14


14
	
2
context_tracking_init
6
(
6
)
6
;
14


14
	
7
/* init some links before init_ISA_irqs() */
14


14
	
2
early_irq_init
6
(
6
)
6
;
14


14
	
2
init_IRQ
6
(
6
)
6
;
14


14
	
2
tick_init
6
(
6
)
6
;
14


14
	
2
rcu_init_nohz
6
(
6
)
6
;
14


14
	
2
init_timers
6
(
6
)
6
;
14


14
	
2
hrtimers_init
6
(
6
)
6
;
14


14
	
2
softirq_init
6
(
6
)
6
;
14


14
	
2
timekeeping_init
6
(
6
)
6
;
14


14
	
2
time_init
6
(
6
)
6
;
14


14
	
2
sched_clock_postinit
6
(
6
)
6
;
14


14
	
2
printk_safe_init
6
(
6
)
6
;
14


14
	
2
perf_event_init
6
(
6
)
6
;
14


14
	
2
profile_init
6
(
6
)
6
;
14


14
	
2
call_function_init
6
(
6
)
6
;
14


14
	
2
WARN
6
(
5
!
2
irqs_disabled
6
(
6
)
6
,
14
 
12
"Interrupts were enabled early\n"
6
)
6
;
14


14
	
2
early_boot_irqs_disabled
14
 
6
=
14
 
2
false
6
;
14


14
	
2
local_irq_enable
6
(
6
)
6
;
14


14


14
	
2
kmem_cache_init_late
6
(
6
)
6
;
14


14


14
	
7
/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
14


14
	
2
console_init
6
(
6
)
6
;
14


14
	
1
if
14
 
6
(
2
panic_later
6
)
14


14
	
14
	
2
panic
6
(
12
"Too many boot %s vars at `%s'"
6
,
14
 
2
panic_later
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
14
 
14
 
2
panic_param
6
)
6
;
14


14


14
	
2
lockdep_info
6
(
6
)
6
;
14


14


14
	
7
/*
	 * Need to run this when irqs are enabled, because it wants
	 * to self-test [hard/soft]-irqs on/off lock inversion bugs
	 * too:
	 */
14


14
	
2
locking_selftest
6
(
6
)
6
;
14


14


14
	
7
/*
	 * This needs to be called before any devices perform DMA
	 * operations that might use the SWIOTLB bounce buffers. It will
	 * mark the bounce buffers as decrypted so that their usage will
	 * not cause "plain-text" data to be decrypted when accessed.
	 */
14


14
	
2
mem_encrypt_init
6
(
6
)
6
;
14


14


9
#ifdef CONFIG_BLK_DEV_INITRD
14


14
	
1
if
14
 
6
(
2
initrd_start
14
 
5
&&
14
 
5
!
2
initrd_below_start_ok
14
 
5
&&
14


14
	
14
 
14
 
14
 
14
 
2
page_to_pfn
6
(
2
virt_to_page
6
(
6
(
1
void
14
 
5
*
6
)
2
initrd_start
6
)
6
)
14
 
5
<
14
 
2
min_low_pfn
6
)
14
 
6
{
14


14
	
14
	
2
pr_crit
6
(
12
"initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n"
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
2
page_to_pfn
6
(
2
virt_to_page
6
(
6
(
1
void
14
 
5
*
6
)
2
initrd_start
6
)
6
)
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
2
min_low_pfn
6
)
6
;
14


14
	
14
	
2
initrd_start
14
 
6
=
14
 
3
0
6
;
14


14
	
6
}
14


9
#endif
14


14
	
2
page_ext_init
6
(
6
)
6
;
14


14
	
2
kmemleak_init
6
(
6
)
6
;
14


14
	
2
debug_objects_mem_init
6
(
6
)
6
;
14


14
	
2
setup_per_cpu_pageset
6
(
6
)
6
;
14


14
	
2
numa_policy_init
6
(
6
)
6
;
14


14
	
1
if
14
 
6
(
2
late_time_init
6
)
14


14
	
14
	
2
late_time_init
6
(
6
)
6
;
14


14
	
2
calibrate_delay
6
(
6
)
6
;
14


14
	
2
pidmap_init
6
(
6
)
6
;
14


14
	
2
anon_vma_init
6
(
6
)
6
;
14


14
	
2
acpi_early_init
6
(
6
)
6
;
14


9
#ifdef CONFIG_X86
14


14
	
1
if
14
 
6
(
2
efi_enabled
6
(
2
EFI_RUNTIME_SERVICES
6
)
6
)
14


14
	
14
	
2
efi_enter_virtual_mode
6
(
6
)
6
;
14


9
#endif
14


9
#ifdef CONFIG_X86_ESPFIX64
14


14
	
7
/* Should be run before the first non-init thread is created */
14


14
	
2
init_espfix_bsp
6
(
6
)
6
;
14


9
#endif
14


14
	
2
thread_stack_cache_init
6
(
6
)
6
;
14


14
	
2
cred_init
6
(
6
)
6
;
14


14
	
2
fork_init
6
(
6
)
6
;
14


14
	
2
proc_caches_init
6
(
6
)
6
;
14


14
	
2
buffer_init
6
(
6
)
6
;
14


14
	
2
key_init
6
(
6
)
6
;
14


14
	
2
security_init
6
(
6
)
6
;
14


14
	
2
dbg_late_init
6
(
6
)
6
;
14


14
	
2
vfs_caches_init
6
(
6
)
6
;
14


14
	
2
pagecache_init
6
(
6
)
6
;
14


14
	
2
signals_init
6
(
6
)
6
;
14


14
	
2
proc_root_init
6
(
6
)
6
;
14


14
	
2
nsfs_init
6
(
6
)
6
;
14


14
	
2
cpuset_init
6
(
6
)
6
;
14


14
	
2
cgroup_init
6
(
6
)
6
;
14


14
	
2
taskstats_init_early
6
(
6
)
6
;
14


14
	
2
delayacct_init
6
(
6
)
6
;
14


14


14
	
2
check_bugs
6
(
6
)
6
;
14


14


14
	
2
acpi_subsystem_init
6
(
6
)
6
;
14


14
	
2
arch_post_acpi_subsys_init
6
(
6
)
6
;
14


14
	
2
sfi_init_late
6
(
6
)
6
;
14


14


14
	
1
if
14
 
6
(
2
efi_enabled
6
(
2
EFI_RUNTIME_SERVICES
6
)
6
)
14
 
6
{
14


14
	
14
	
2
efi_free_boot_services
6
(
6
)
6
;
14


14
	
6
}
14


14


14
	
7
/* Do the rest non-__init'ed, we're now alive */
14


14
	
2
rest_init
6
(
6
)
6
;
14


6
}
14


14


7
/* Call all constructor functions linked into the kernel. */
14


1
static
14
 
1
void
14
 
2
__init
14
 
2
do_ctors
6
(
1
void
6
)
14


6
{
14


9
#ifdef CONFIG_CONSTRUCTORS
14


14
	
2
ctor_fn_t
14
 
5
*
2
fn
14
 
6
=
14
 
6
(
2
ctor_fn_t
14
 
5
*
6
)
14
 
2
__ctors_start
6
;
14


14


14
	
1
for
14
 
6
(
6
;
14
 
2
fn
14
 
5
<
14
 
6
(
2
ctor_fn_t
14
 
5
*
6
)
14
 
2
__ctors_end
6
;
14
 
2
fn
5
++
6
)
14


14
	
14
	
6
(
5
*
2
fn
6
)
6
(
6
)
6
;
14


9
#endif
14


6
}
14


14


2
bool
14
 
2
initcall_debug
6
;
14


2
core_param
6
(
2
initcall_debug
6
,
14
 
2
initcall_debug
6
,
14
 
2
bool
6
,
14
 
3
0644
6
)
6
;
14


14


9
#ifdef CONFIG_KALLSYMS
14


1
struct
14
 
2
blacklist_entry
14
 
6
{
14


14
	
1
struct
14
 
2
list_head
14
 
2
next
6
;
14


14
	
1
char
14
 
5
*
2
buf
6
;
14


6
}
6
;
14


14


1
static
14
 
2
__initdata_or_module
14
 
2
LIST_HEAD
6
(
2
blacklisted_initcalls
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init
14
 
2
initcall_blacklist
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
1
char
14
 
5
*
2
str_entry
6
;
14


14
	
1
struct
14
 
2
blacklist_entry
14
 
5
*
2
entry
6
;
14


14


14
	
7
/* str argument is a comma-separated list of functions */
14


14
	
1
do
14
 
6
{
14


14
	
14
	
2
str_entry
14
 
6
=
14
 
2
strsep
6
(
5
&
2
str
6
,
14
 
12
","
6
)
6
;
14


14
	
14
	
1
if
14
 
6
(
2
str_entry
6
)
14
 
6
{
14


14
	
14
	
14
	
2
pr_debug
6
(
12
"blacklisting initcall %s\n"
6
,
14
 
2
str_entry
6
)
6
;
14


14
	
14
	
14
	
2
entry
14
 
6
=
14
 
2
alloc_bootmem
6
(
1
sizeof
6
(
5
*
2
entry
6
)
6
)
6
;
14


14
	
14
	
14
	
2
entry
5
-
5
>
2
buf
14
 
6
=
14
 
2
alloc_bootmem
6
(
2
strlen
6
(
2
str_entry
6
)
14
 
5
+
14
 
3
1
6
)
6
;
14


14
	
14
	
14
	
2
strcpy
6
(
2
entry
5
-
5
>
2
buf
6
,
14
 
2
str_entry
6
)
6
;
14


14
	
14
	
14
	
2
list_add
6
(
5
&
2
entry
5
-
5
>
2
next
6
,
14
 
5
&
2
blacklisted_initcalls
6
)
6
;
14


14
	
14
	
6
}
14


14
	
6
}
14
 
1
while
14
 
6
(
2
str_entry
6
)
6
;
14


14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


1
static
14
 
2
bool
14
 
2
__init_or_module
14
 
2
initcall_blacklisted
6
(
2
initcall_t
14
 
2
fn
6
)
14


6
{
14


14
	
1
struct
14
 
2
blacklist_entry
14
 
5
*
2
entry
6
;
14


14
	
1
char
14
 
2
fn_name
6
[
2
KSYM_SYMBOL_LEN
6
]
6
;
14


14
	
1
unsigned
14
 
1
long
14
 
2
addr
6
;
14


14


14
	
1
if
14
 
6
(
2
list_empty
6
(
5
&
2
blacklisted_initcalls
6
)
6
)
14


14
	
14
	
1
return
14
 
2
false
6
;
14


14


14
	
2
addr
14
 
6
=
14
 
6
(
1
unsigned
14
 
1
long
6
)
14
 
2
dereference_function_descriptor
6
(
2
fn
6
)
6
;
14


14
	
2
sprint_symbol_no_offset
6
(
2
fn_name
6
,
14
 
2
addr
6
)
6
;
14


14


14
	
7
/*
	 * fn will be "function_name [module_name]" where [module_name] is not
	 * displayed for built-in init functions.  Strip off the [module_name].
	 */
14


14
	
2
strreplace
6
(
2
fn_name
6
,
14
 
11
' '
6
,
14
 
11
'\0'
6
)
6
;
14


14


14
	
2
list_for_each_entry
6
(
2
entry
6
,
14
 
5
&
2
blacklisted_initcalls
6
,
14
 
2
next
6
)
14
 
6
{
14


14
	
14
	
1
if
14
 
6
(
5
!
2
strcmp
6
(
2
fn_name
6
,
14
 
2
entry
5
-
5
>
2
buf
6
)
6
)
14
 
6
{
14


14
	
14
	
14
	
2
pr_debug
6
(
12
"initcall %s blacklisted\n"
6
,
14
 
2
fn_name
6
)
6
;
14


14
	
14
	
14
	
1
return
14
 
2
true
6
;
14


14
	
14
	
6
}
14


14
	
6
}
14


14


14
	
1
return
14
 
2
false
6
;
14


6
}
14


9
#else
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
initcall_blacklist
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
2
pr_warn
6
(
12
"initcall_blacklist requires CONFIG_KALLSYMS\n"
6
)
6
;
14


14
	
1
return
14
 
3
0
6
;
14


6
}
14


14


1
static
14
 
2
bool
14
 
2
__init_or_module
14
 
2
initcall_blacklisted
6
(
2
initcall_t
14
 
2
fn
6
)
14


6
{
14


14
	
1
return
14
 
2
false
6
;
14


6
}
14


9
#endif
14


2
__setup
6
(
12
"initcall_blacklist="
6
,
14
 
2
initcall_blacklist
6
)
6
;
14


14


1
static
14
 
1
int
14
 
2
__init_or_module
14
 
2
do_one_initcall_debug
6
(
2
initcall_t
14
 
2
fn
6
)
14


6
{
14


14
	
2
ktime_t
14
 
2
calltime
6
,
14
 
2
delta
6
,
14
 
2
rettime
6
;
14


14
	
1
unsigned
14
 
1
long
14
 
1
long
14
 
2
duration
6
;
14


14
	
1
int
14
 
2
ret
6
;
14


14


14
	
2
printk
6
(
2
KERN_DEBUG
14
 
12
"calling  %pF @ %i\n"
6
,
14
 
2
fn
6
,
14
 
2
task_pid_nr
6
(
2
current
6
)
6
)
6
;
14


14
	
2
calltime
14
 
6
=
14
 
2
ktime_get
6
(
6
)
6
;
14


14
	
2
ret
14
 
6
=
14
 
2
fn
6
(
6
)
6
;
14


14
	
2
rettime
14
 
6
=
14
 
2
ktime_get
6
(
6
)
6
;
14


14
	
2
delta
14
 
6
=
14
 
2
ktime_sub
6
(
2
rettime
6
,
14
 
2
calltime
6
)
6
;
14


14
	
2
duration
14
 
6
=
14
 
6
(
1
unsigned
14
 
1
long
14
 
1
long
6
)
14
 
2
ktime_to_ns
6
(
2
delta
6
)
14
 
5
>>
14
 
3
10
6
;
14


14
	
2
printk
6
(
2
KERN_DEBUG
14
 
12
"initcall %pF returned %d after %lld usecs\n"
6
,
14


14
	
14
	
14
 
2
fn
6
,
14
 
2
ret
6
,
14
 
2
duration
6
)
6
;
14


14


14
	
1
return
14
 
2
ret
6
;
14


6
}
14


14


1
int
14
 
2
__init_or_module
14
 
2
do_one_initcall
6
(
2
initcall_t
14
 
2
fn
6
)
14


6
{
14


14
	
1
int
14
 
2
count
14
 
6
=
14
 
2
preempt_count
6
(
6
)
6
;
14


14
	
1
int
14
 
2
ret
6
;
14


14
	
1
char
14
 
2
msgbuf
6
[
3
64
6
]
6
;
14


14


14
	
1
if
14
 
6
(
2
initcall_blacklisted
6
(
2
fn
6
)
6
)
14


14
	
14
	
1
return
14
 
5
-
2
EPERM
6
;
14


14


14
	
1
if
14
 
6
(
2
initcall_debug
6
)
14


14
	
14
	
2
ret
14
 
6
=
14
 
2
do_one_initcall_debug
6
(
2
fn
6
)
6
;
14


14
	
1
else
14


14
	
14
	
2
ret
14
 
6
=
14
 
2
fn
6
(
6
)
6
;
14


14


14
	
2
msgbuf
6
[
3
0
6
]
14
 
6
=
14
 
3
0
6
;
14


14


14
	
1
if
14
 
6
(
2
preempt_count
6
(
6
)
14
 
5
!=
14
 
2
count
6
)
14
 
6
{
14


14
	
14
	
2
sprintf
6
(
2
msgbuf
6
,
14
 
12
"preemption imbalance "
6
)
6
;
14


14
	
14
	
2
preempt_count_set
6
(
2
count
6
)
6
;
14


14
	
6
}
14


14
	
1
if
14
 
6
(
2
irqs_disabled
6
(
6
)
6
)
14
 
6
{
14


14
	
14
	
2
strlcat
6
(
2
msgbuf
6
,
14
 
12
"disabled interrupts "
6
,
14
 
1
sizeof
6
(
2
msgbuf
6
)
6
)
6
;
14


14
	
14
	
2
local_irq_enable
6
(
6
)
6
;
14


14
	
6
}
14


14
	
2
WARN
6
(
2
msgbuf
6
[
3
0
6
]
6
,
14
 
12
"initcall %pF returned with %s\n"
6
,
14
 
2
fn
6
,
14
 
2
msgbuf
6
)
6
;
14


14


14
	
2
add_latent_entropy
6
(
6
)
6
;
14


14
	
1
return
14
 
2
ret
6
;
14


6
}
14


14


14


1
extern
14
 
2
initcall_t
14
 
2
__initcall_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall0_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall1_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall2_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall3_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall4_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall5_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall6_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall7_start
6
[
6
]
6
;
14


1
extern
14
 
2
initcall_t
14
 
2
__initcall_end
6
[
6
]
6
;
14


14


1
static
14
 
2
initcall_t
14
 
5
*
2
initcall_levels
6
[
6
]
14
 
2
__initdata
14
 
6
=
14
 
6
{
14


14
	
2
__initcall0_start
6
,
14


14
	
2
__initcall1_start
6
,
14


14
	
2
__initcall2_start
6
,
14


14
	
2
__initcall3_start
6
,
14


14
	
2
__initcall4_start
6
,
14


14
	
2
__initcall5_start
6
,
14


14
	
2
__initcall6_start
6
,
14


14
	
2
__initcall7_start
6
,
14


14
	
2
__initcall_end
6
,
14


6
}
6
;
14


14


7
/* Keep these in sync with initcalls in include/linux/init.h */
14


1
static
14
 
1
char
14
 
5
*
2
initcall_level_names
6
[
6
]
14
 
2
__initdata
14
 
6
=
14
 
6
{
14


14
	
12
"early"
6
,
14


14
	
12
"core"
6
,
14


14
	
12
"postcore"
6
,
14


14
	
12
"arch"
6
,
14


14
	
12
"subsys"
6
,
14


14
	
12
"fs"
6
,
14


14
	
12
"device"
6
,
14


14
	
12
"late"
6
,
14


6
}
6
;
14


14


1
static
14
 
1
void
14
 
2
__init
14
 
2
do_initcall_level
6
(
1
int
14
 
2
level
6
)
14


6
{
14


14
	
2
initcall_t
14
 
5
*
2
fn
6
;
14


14


14
	
2
strcpy
6
(
2
initcall_command_line
6
,
14
 
2
saved_command_line
6
)
6
;
14


14
	
2
parse_args
6
(
2
initcall_level_names
6
[
2
level
6
]
6
,
14


14
	
14
	
14
 
14
 
14
 
2
initcall_command_line
6
,
14
 
2
__start___param
6
,
14


14
	
14
	
14
 
14
 
14
 
2
__stop___param
14
 
5
-
14
 
2
__start___param
6
,
14


14
	
14
	
14
 
14
 
14
 
2
level
6
,
14
 
2
level
6
,
14


14
	
14
	
14
 
14
 
14
 
2
NULL
6
,
14
 
5
&
2
repair_env_string
6
)
6
;
14


14


14
	
1
for
14
 
6
(
2
fn
14
 
6
=
14
 
2
initcall_levels
6
[
2
level
6
]
6
;
14
 
2
fn
14
 
5
<
14
 
2
initcall_levels
6
[
2
level
3
+1
6
]
6
;
14
 
2
fn
5
++
6
)
14


14
	
14
	
2
do_one_initcall
6
(
5
*
2
fn
6
)
6
;
14


6
}
14


14


1
static
14
 
1
void
14
 
2
__init
14
 
2
do_initcalls
6
(
1
void
6
)
14


6
{
14


14
	
1
int
14
 
2
level
6
;
14


14


14
	
1
for
14
 
6
(
2
level
14
 
6
=
14
 
3
0
6
;
14
 
2
level
14
 
5
<
14
 
2
ARRAY_SIZE
6
(
2
initcall_levels
6
)
14
 
5
-
14
 
3
1
6
;
14
 
2
level
5
++
6
)
14


14
	
14
	
2
do_initcall_level
6
(
2
level
6
)
6
;
14


6
}
14


14


7
/*
 * Ok, the machine is now initialized. None of the devices
 * have been touched yet, but the CPU subsystem is up and
 * running, and memory and process management works.
 *
 * Now we can finally start doing some real work..
 */
14


1
static
14
 
1
void
14
 
2
__init
14
 
2
do_basic_setup
6
(
1
void
6
)
14


6
{
14


14
	
2
cpuset_init_smp
6
(
6
)
6
;
14


14
	
2
shmem_init
6
(
6
)
6
;
14


14
	
2
driver_init
6
(
6
)
6
;
14


14
	
2
init_irq_proc
6
(
6
)
6
;
14


14
	
2
do_ctors
6
(
6
)
6
;
14


14
	
2
usermodehelper_enable
6
(
6
)
6
;
14


14
	
2
do_initcalls
6
(
6
)
6
;
14


6
}
14


14


1
static
14
 
1
void
14
 
2
__init
14
 
2
do_pre_smp_initcalls
6
(
1
void
6
)
14


6
{
14


14
	
2
initcall_t
14
 
5
*
2
fn
6
;
14


14


14
	
1
for
14
 
6
(
2
fn
14
 
6
=
14
 
2
__initcall_start
6
;
14
 
2
fn
14
 
5
<
14
 
2
__initcall0_start
6
;
14
 
2
fn
5
++
6
)
14


14
	
14
	
2
do_one_initcall
6
(
5
*
2
fn
6
)
6
;
14


6
}
14


14


7
/*
 * This function requests modules which should be loaded by default and is
 * called twice right after initrd is mounted and right before init is
 * exec'd.  If such modules are on either initrd or rootfs, they will be
 * loaded before control is passed to userland.
 */
14


1
void
14
 
2
__init
14
 
2
load_default_modules
6
(
1
void
6
)
14


6
{
14


14
	
2
load_default_elevator_module
6
(
6
)
6
;
14


6
}
14


14


1
static
14
 
1
int
14
 
2
run_init_process
6
(
1
const
14
 
1
char
14
 
5
*
2
init_filename
6
)
14


6
{
14


14
	
2
argv_init
6
[
3
0
6
]
14
 
6
=
14
 
2
init_filename
6
;
14


14
	
1
return
14
 
2
do_execve
6
(
2
getname_kernel
6
(
2
init_filename
6
)
6
,
14


14
	
14
	
6
(
1
const
14
 
1
char
14
 
2
__user
14
 
5
*
1
const
14
 
2
__user
14
 
5
*
6
)
2
argv_init
6
,
14


14
	
14
	
6
(
1
const
14
 
1
char
14
 
2
__user
14
 
5
*
1
const
14
 
2
__user
14
 
5
*
6
)
2
envp_init
6
)
6
;
14


6
}
14


14


1
static
14
 
1
int
14
 
2
try_to_run_init_process
6
(
1
const
14
 
1
char
14
 
5
*
2
init_filename
6
)
14


6
{
14


14
	
1
int
14
 
2
ret
6
;
14


14


14
	
2
ret
14
 
6
=
14
 
2
run_init_process
6
(
2
init_filename
6
)
6
;
14


14


14
	
1
if
14
 
6
(
2
ret
14
 
5
&&
14
 
2
ret
14
 
5
!=
14
 
5
-
2
ENOENT
6
)
14
 
6
{
14


14
	
14
	
2
pr_err
6
(
12
"Starting init: %s exists but couldn't execute it (error %d)\n"
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
14
 
14
 
14
 
2
init_filename
6
,
14
 
2
ret
6
)
6
;
14


14
	
6
}
14


14


14
	
1
return
14
 
2
ret
6
;
14


6
}
14


14


1
static
14
 
2
noinline
14
 
1
void
14
 
2
__init
14
 
2
kernel_init_freeable
6
(
1
void
6
)
6
;
14


14


9
#if defined(CONFIG_STRICT_KERNEL_RWX) || defined(CONFIG_STRICT_MODULE_RWX)
14


2
bool
14
 
2
rodata_enabled
14
 
2
__ro_after_init
14
 
6
=
14
 
2
true
6
;
14


1
static
14
 
1
int
14
 
2
__init
14
 
2
set_debug_rodata
6
(
1
char
14
 
5
*
2
str
6
)
14


6
{
14


14
	
1
return
14
 
2
strtobool
6
(
2
str
6
,
14
 
5
&
2
rodata_enabled
6
)
6
;
14


6
}
14


2
__setup
6
(
12
"rodata="
6
,
14
 
2
set_debug_rodata
6
)
6
;
14


9
#endif
14


14


9
#ifdef CONFIG_STRICT_KERNEL_RWX
14


1
static
14
 
1
void
14
 
2
mark_readonly
6
(
1
void
6
)
14


6
{
14


14
	
1
if
14
 
6
(
2
rodata_enabled
6
)
14
 
6
{
14


14
	
14
	
2
mark_rodata_ro
6
(
6
)
6
;
14


14
	
14
	
2
rodata_test
6
(
6
)
6
;
14


14
	
6
}
14
 
1
else
14


14
	
14
	
2
pr_info
6
(
12
"Kernel memory protection disabled.\n"
6
)
6
;
14


6
}
14


9
#else
14


1
static
14
 
2
inline
14
 
1
void
14
 
2
mark_readonly
6
(
1
void
6
)
14


6
{
14


14
	
2
pr_warn
6
(
12
"This architecture does not have kernel memory protection.\n"
6
)
6
;
14


6
}
14


9
#endif
14


14


1
static
14
 
1
int
14
 
2
__ref
14
 
2
kernel_init
6
(
1
void
14
 
5
*
2
unused
6
)
14


6
{
14


14
	
1
int
14
 
2
ret
6
;
14


14


14
	
2
kernel_init_freeable
6
(
6
)
6
;
14


14
	
7
/* need to finish all async __init code before freeing the memory */
14


14
	
2
async_synchronize_full
6
(
6
)
6
;
14


14
	
2
ftrace_free_init_mem
6
(
6
)
6
;
14


14
	
2
free_initmem
6
(
6
)
6
;
14


14
	
2
mark_readonly
6
(
6
)
6
;
14


14
	
2
system_state
14
 
6
=
14
 
2
SYSTEM_RUNNING
6
;
14


14
	
2
numa_default_policy
6
(
6
)
6
;
14


14


14
	
2
rcu_end_inkernel_boot
6
(
6
)
6
;
14


14


14
	
1
if
14
 
6
(
2
ramdisk_execute_command
6
)
14
 
6
{
14


14
	
14
	
2
ret
14
 
6
=
14
 
2
run_init_process
6
(
2
ramdisk_execute_command
6
)
6
;
14


14
	
14
	
1
if
14
 
6
(
5
!
2
ret
6
)
14


14
	
14
	
14
	
1
return
14
 
3
0
6
;
14


14
	
14
	
2
pr_err
6
(
12
"Failed to execute %s (error %d)\n"
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
14
 
14
 
14
 
2
ramdisk_execute_command
6
,
14
 
2
ret
6
)
6
;
14


14
	
6
}
14


14


14
	
7
/*
	 * We try each of these until one succeeds.
	 *
	 * The Bourne shell can be used instead of init if we are
	 * trying to recover a really broken machine.
	 */
14


14
	
1
if
14
 
6
(
2
execute_command
6
)
14
 
6
{
14


14
	
14
	
2
ret
14
 
6
=
14
 
2
run_init_process
6
(
2
execute_command
6
)
6
;
14


14
	
14
	
1
if
14
 
6
(
5
!
2
ret
6
)
14


14
	
14
	
14
	
1
return
14
 
3
0
6
;
14


14
	
14
	
2
panic
6
(
12
"Requested init %s failed (error %d)."
6
,
14


14
	
14
	
14
 
14
 
14
 
14
 
14
 
14
 
2
execute_command
6
,
14
 
2
ret
6
)
6
;
14


14
	
6
}
14


14
	
1
if
14
 
6
(
5
!
2
try_to_run_init_process
6
(
12
"/sbin/init"
6
)
14
 
5
||
14


14
	
14
 
14
 
14
 
14
 
5
!
2
try_to_run_init_process
6
(
12
"/etc/init"
6
)
14
 
5
||
14


14
	
14
 
14
 
14
 
14
 
5
!
2
try_to_run_init_process
6
(
12
"/bin/init"
6
)
14
 
5
||
14


14
	
14
 
14
 
14
 
14
 
5
!
2
try_to_run_init_process
6
(
12
"/bin/sh"
6
)
6
)
14


14
	
14
	
1
return
14
 
3
0
6
;
14


14


14
	
2
panic
6
(
12
"No working init found.  Try passing init= option to kernel. "
14


14
	
14
 
14
 
14
 
14
 
14
 
14
 
12
"See Linux Documentation/admin-guide/init.rst for guidance."
6
)
6
;
14


6
}
14


14


1
static
14
 
2
noinline
14
 
1
void
14
 
2
__init
14
 
2
kernel_init_freeable
6
(
1
void
6
)
14


6
{
14


14
	
7
/*
	 * Wait until kthreadd is all set-up.
	 */
14


14
	
2
wait_for_completion
6
(
5
&
2
kthreadd_done
6
)
6
;
14


14


14
	
7
/* Now the scheduler is fully set up and can do blocking allocations */
14


14
	
2
gfp_allowed_mask
14
 
6
=
14
 
2
__GFP_BITS_MASK
6
;
14


14


14
	
7
/*
	 * init can allocate pages on any node
	 */
14


14
	
2
set_mems_allowed
6
(
2
node_states
6
[
2
N_MEMORY
6
]
6
)
6
;
14


14


14
	
2
cad_pid
14
 
6
=
14
 
2
task_pid
6
(
2
current
6
)
6
;
14


14


14
	
2
smp_prepare_cpus
6
(
2
setup_max_cpus
6
)
6
;
14


14


14
	
2
workqueue_init
6
(
6
)
6
;
14


14


14
	
2
init_mm_internals
6
(
6
)
6
;
14


14


14
	
2
do_pre_smp_initcalls
6
(
6
)
6
;
14


14
	
2
lockup_detector_init
6
(
6
)
6
;
14


14


14
	
2
smp_init
6
(
6
)
6
;
14


14
	
2
sched_init_smp
6
(
6
)
6
;
14


14


14
	
2
page_alloc_init_late
6
(
6
)
6
;
14


14


14
	
2
do_basic_setup
6
(
6
)
6
;
14


14


14
	
7
/* Open the /dev/console on the rootfs, this should never fail */
14


14
	
1
if
14
 
6
(
2
sys_open
6
(
6
(
1
const
14
 
1
char
14
 
2
__user
14
 
5
*
6
)
14
 
12
"/dev/console"
6
,
14
 
2
O_RDWR
6
,
14
 
3
0
6
)
14
 
5
<
14
 
3
0
6
)
14


14
	
14
	
2
pr_err
6
(
12
"Warning: unable to open an initial console.\n"
6
)
6
;
14


14


14
	
6
(
1
void
6
)
14
 
2
sys_dup
6
(
3
0
6
)
6
;
14


14
	
6
(
1
void
6
)
14
 
2
sys_dup
6
(
3
0
6
)
6
;
14


14
	
7
/*
	 * check if there is an early userspace init.  If yes, let it do all
	 * the work
	 */
14


14


14
	
1
if
14
 
6
(
5
!
2
ramdisk_execute_command
6
)
14


14
	
14
	
2
ramdisk_execute_command
14
 
6
=
14
 
12
"/init"
6
;
14


14


14
	
1
if
14
 
6
(
2
sys_access
6
(
6
(
1
const
14
 
1
char
14
 
2
__user
14
 
5
*
6
)
14
 
2
ramdisk_execute_command
6
,
14
 
3
0
6
)
14
 
5
!=
14
 
3
0
6
)
14
 
6
{
14


14
	
14
	
2
ramdisk_execute_command
14
 
6
=
14
 
2
NULL
6
;
14


14
	
14
	
2
prepare_namespace
6
(
6
)
6
;
14


14
	
6
}
14


14


14
	
7
/*
	 * Ok, we have completed the initial bootup, and
	 * we're essentially up and running. Get rid of the
	 * initmem segments and start the user-mode stuff..
	 *
	 * rootfs is available now, try loading the public keys
	 * and default modules
	 */
14


14


14
	
2
integrity_load_keys
6
(
6
)
6
;
14


14
	
2
load_default_modules
6
(
6
)
6
;
14


6
}
14


